INSERT INTO article_list ( article_title, article_create_time, article_summary, article_content, article_tag )
  VALUES
( 'Ajax及 GET、POST 区别', '2017-05-01 13:42:33', 'GET请求数据按照查询字符串（名称/值对）方式，放置在HTTP请求协议头（headers）中，也就是URL之后； 而POST提交的数据则放在实体的主体（request-body）中.',"## XMLHttpRequest对象\n\n- open():接受三个参数，发送请求名，url和是否异步请求的布尔值。\n- readystatechange 事件监听，DOM0级方法，因为并非所有浏览器都支持 DOM2级方法。\n- abort()方法可以取消异步请求，终止请求之后，还应该对 xhr 进行解引用操作，由于内存原因，不建议重用 xhr 对象。\n\nxhr.readyState状态码|说明\n---|---\n0|尚未初始化，还没有调用 open 方法\n1|open()方法已调用，还未发送 send()方法\n2|send()方法已调用，尚未接受响应\n3|已经开始接受部分响应，但没有完全接收\n4|响应已经接受完成\n\n```javascript\nvar xhr = new XMLHttpRequest()\nxhr.onreadystatechange = function() {\n\tif(xhr.readyState === 4) {\n\t\tif(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304) {\n\t\t   console.log(xhr.responseText)\n\t\t}\n\t}\n}\nxhr.open('GET', url, true)\nxhr.send(null)\n```\n\n### HTTP 头部信息\n- 使用 setRequestHeader()可以设置自定义的请求头部信息。接收两个参数，头部字段的名称和头部字段值。**必须在 open 方法后，send 方法前进行设置。**\n\n```javascript\nxhr.open('get', url, true)\nxhr.setRequestHeader('myHeader', 'myValue') //open 和 send 中间设置\nxhr.send(null)\n```\n\n- 调用 getResponseHeader()方法可以取得头部信息，接受一个包含头部字段名。\n- 调用 getAllResponseHeaders()可以取得所有头部信息。是一个格式化过的长字符串。\n\n```javascript\nvar header = xhr.getResponseHeader('myHeader') //'myValue'\nvar allHeaders = xhr.getAllResponseHeaders() //返回一个长字符串\n```\n\n### GET 请求\n- 使用 get 请求通常会发生一个错误，就是查询字符串的格式有问题，一定要使用 encodeURIConponent()进行转码后在放到 url 末尾。\n- 键值对以&分隔，url 跟？再接参数字符串。\n\n```javascript\nfunction addUrl(url, key, value) {  //添加参数的方法，向现有 url 末尾添加参数\n\turl += url.indexOf('?') == -1 ? '?' : '&'\n\turl += encodeURIComponent(name) + '=' + encodeURLIIComponent(value)\n\treturn url\n}\n\nurl = addUrl(url, 'username', 'www')\nxhr.open('get', url, true)\n```\n\n### POST请求\n- 默认情况下，服务器对 POST 请求不会和表单请求一视同仁，所以我们用 xhr 模仿表单提交，首先将头部 Content-type 信息设置为 application/x-www-form-urlencoded，也就是表单提交时的内容类型，然后以适当格式创建一个字符串。\n\n```javascript\nfunction submitData() {\n\tvar xhr = new XMLHttpRequest()\n\txhr.onreadystatechange = function(){...}\n\t\n\txhr.open('post', url, true)\n\t\n\txhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded') //设置头部信息\n\t\n\tvar form = document.getElementById('user-info')\n\txhr.send(serialize(form)) //序列化表单数据的一个自定义方法\n}\n```\n\n## XMLHTTPRequest2级\n###FormData\n- FormData 类型，为序列化表单以及创建与表单格式相同的数据提供便利。\n- FormData类型有 append 方法，接受键值对这两个参数。\n\n```javascript\nvar data = new FormData()\ndata.append('name', 'Nicholas') // FormData.append()方法\n\nvar data = new FormData(document.form[0]) //也可以直接传入一个表单元素\n```\n\n- 创建 FormData 实例后，可以传给 send 方法\n\n```javascript\n xhr.open('post', url, true)\n var form = document.getElementById('user-info')\n xhr.send(new FormData(form))\n```\n\n## 进度事件\n### load 事件\n- 兼容性 IE8+。\n- 只要浏览器接受响应，不管状态如何，都会触发 load 事件。所以还是得判断 status 状态码确定数据是否真的可用。\n\n```javascript\nvar xhr = new XMLHttpRequest()\nxhr.onload = function() { //实际只是少了 readyState判断，相比之下\n\tif(xhr.status === 200 || xhr.status === 304) {\n\t\tconsole.log(xhr.responseText)\n\t}\n}\nxhr.open('get', url, true)\nxhr.send(null)\n```\n\n### progress 事件\n- xhr.onprogress()事件会接收一个 event 对象，target 属性指向 xhr 对象，有三个额外的属性。\n\n属性值|说明\n---|---\nevent.lengthComputable|进度信息是否可用的布尔值\nevent.position|表示已经接收的字节数\nevent.totalSize|表示根据 Content-Length 响应头部确定的预期字节数\n\n```javascript\nvar xhr = new XMLHttpRequest()\nxhr.onprogress = function(e) { //进度事件\n\tif(e.lengthComputable) {\n\t\tvar divProgress = document.getElementbyId('div')\n\t\tdivProgress.innerHTML = e.position + '/' + e.totalSize\n\t}\n}\nxhr.onload = function() {...}\n\t//记得 progress 事件要在 open 之前调用，和 onload 一样\nxhr.open(...)\nxhr.send(null)\n```\n\n## GET和 POST 区别\n### 请求方式\n-  GET 是从服务器上获取数据，POST 则是向指定资源提交要被处理的数据。\n\n### 格式\n- GET请求数据按照查询字符串（名称/值对）方式，放置在HTTP请求协议头（headers）中，也就是URL之后；\n而POST提交的数据则放在实体的主体（request-body）中.\n\n### 缓存 书签 历史纪录 默认 method\n1. GET会被缓存，POST不能。\n2. 书签： GET可收藏为书签，POST不可收藏为书签\n3. 历史记录： GET请求的URL，参数会被浏览器保留在历史中,POST参数不会。\n4. 默认请求： 在from提交的时候，如果不指定Method，则默认为get请求。\n\n### 响应速度\n- GET请求是可以被客户端缓存的。会比POST高效。\n-  AJAX环境中GET响应快速，POST需要先发送HTTP头部(headers) 服务器接收成功返回100状态码，再发送报文实体的主体(request-body)中的数据。\n\n### 大小限制\n- GET参数是带在URL后面，传统IE中URL的最大可用长度为2048字符，其他浏览器对URL长度限制实现上有所不同。POST请求无长度限制（目前理论上是这样的）。\n- GET提交的数据大小，不同浏览器的限制不同，一般在2k-8K之间，POST提交数据比较大，大小靠服务器的设定值限制，而且某些数据只能用 POST 方法「携带」，比如 file。\n\n\n### 实际中 — POST比GET「相对安全」\n- GET所发送的数据是 URL 的一部分，有时候会直接反应在浏览器的地址栏，现在的浏览器大多会记住曾经输入过的URL（在发送密码或敏感信息时绝不要使用 GET ！）。\n- 试想如果你曾经在别人电脑上填过一个很私密的表单，那么你的这份记录很可能被连没什么电脑常识的人都一览无遗。\n- 但是被抓包之后的POST请求和GET请求是一样裸露的，所以这里是相对的。\n\n### 语义上 — GET比POST「相对安全」\n- 根据HTTP规范，POST表示可能修改变服务器上的资源的请求。\n- 在语义上（restful视角）:\nGET的是获取指定URL上的资源，是读操作。\n重要的一点是不论对某个资源GET多少次，它的状态是不会改变的，\n在这个意义上，我们说GET是安全的（不是被密码学或者数据保护意义上的安全）。\n因为GET是安全的，所以GET返回的内容可以被浏览器，Cache服务器缓存起来。\n\n- POST的语义是修改变服务器上的资源的请求，所以是不安全的，\n每次提交的POST，代码都会认为这个操作会修改资源的状态，\n于是，浏览器在你按下F5的时候会跳出确认框，缓存服务器不会缓存POST请求返回内容。\n\n- 安全的是指没有明显的对用户有影响的副作用(包括修改该资源的状态)。HTTP方法里的GET和HEAD都是安全的。\n- 幂等的是指一个方法不论多少次操作，结果都是一样。PUT(把内容放到指定URL)，DELETE(删除某个URL代表的资源)，虽然都修改了资源内容，但多次操作，结果是相同的，因此和HEAD，GET一样都是幂等的。\n- 所以根据HTTP协议，GET是安全的，也是幂等的，而POST既不是安全的，也不是幂等的。\n\n## 参考文献\n[从HTTP GET和POST的区别说起](http://www.yining.org/2010/05/04/http-get-vs-post-and-thoughts/)\n\n[关于 HTTP GET/POST 请求参数长度最大值的一个理解误区](http://my.oschina.net/leejun2005/blog/136820)\n\n[GET，POST — 简述](http://div.io/topic/1656)\n\n[JS 高级程序设计]()",'JavaScript');
INSERT INTO article_list ( article_title, article_create_time, article_summary, article_content, article_tag )
  VALUES
( '小米的两道闭包面试题', '2017-08-11 17:32:55', '网上看到了这两道题，都挺有意思的，记录~',"网上看到了这两道题，都挺有意思的，记录~\n\n## repeat 函数\n\n```javascript\n// 题目要求！\n\nfunction repeat (func, times, wait) {\n}\n// 这个函数能返回一个新函数，比如这样用\nvar repeatedFun = repeat(alert, 10, 5000)\n调用这个 repeatedFun (\"hellworld\")\n会alert十次 helloworld, 每次间隔5秒\n```\n\n网上给的是 setInterval 的写法，不过考虑到 setInterval 返回值容易忽忽悠悠，还是用 setTimeout来写。\n\n```javascript\nfunction repeat(func, times, wait) {\n    return function () {\n      var num = 0\n      // 保存传参, 以便在 handler 中使用\n      var _arguments = arguments\n\n      function handler() {\n        // 注意此处次数\n        if (num < times) {\n       \t  num++\n          func.apply(null, _arguments)\n          setTimeout(handler, wait)\n        }\n      }\n\n      setTimeout(handler, wait)\n    }\n  }\n```\n\n这个题考察了闭包和 setTimeout 模拟 setInterval 的用法，因为最终要在 handler 方法中执行func，所以要保存 arguments 对象以便下面的闭包函数调用。\n\n次数也踩了坑，递归调用一定要注意终止条件，本来 num++写在 if 之外，觉得不太妥当，还是放在里面。\n\n## stringconcat 函数\n\n```javascript\n// 题目要求！\nvar result1 = stringconcat(\"a\", \"b\")  //result1 = \"a+b\"\nvar stringconcatWithPrefix = stringconcat.prefix(\"hellworld\");\nvar result2 = stringconcatWithPrefix(\"a\", \"b\")  // result2 = \"hellworld+a+b\"\n\n```\n\n一看就比第一个复杂。答案还写了 merge 函数，还有 for 循环什么的，测试用例看起来并没有这么复杂， so给出自己的答案。\n\n```javascript\n function stringconcat() {\n    return Array.prototype.slice.call(arguments).join('+')\n  }\n\n  stringconcat.prefix = function (str) {\n    return function () {\n    // 这个 str参数挺有意思的\n      var arr = [str].concat(Array.prototype.slice.call(arguments))\n      return stringconcat.apply(null, arr)\n    }\n  }\n```\n\n看似 stringconcat.prefix（）返回的只是一个 function，但实际还是保存了外层传进来的参数形成闭包。\n\n另一个坑就是 return function(){}中，不要忘记把 stringconcat.apply的结果 return 回去，一开始我因为没有加 return 导致折腾了一下午！！！\n\n## 参考\n[分享小米的两道面试题](http://www.111cn.net/wy/js-ajax/74972.htm)", 'JavaScript');
INSERT INTO article_list ( article_title, article_create_time, article_summary, article_content, article_tag )
  VALUES
( 'Vue.js 官方示例初探(es6)', '2017-09-13 13:38:52', '感谢作者 @尤小右 大大边写的超级带感的 Vue.js 前端框架，赠送的几个小例子都很有代表性，代码逻辑清晰简明，不禁想抄上一抄嗯。', "# Vue.js 官方示例初探\n感谢作者 @尤小右 大大边写的超级带感的 Vue.js 前端框架，赠送的几个小例子都很有代表性，代码逻辑清晰简明，不禁想抄上一抄嗯。\n\n官方的示例都是 ES5直接编写运行，并没有使用ES6以及构建工具，考虑到以后开发大一些的项目以及官方出品的 vue-cli脚手架，决定这次学习之旅采用两者结合写写官方的示例。\n\n初探步骤：\n\n1. 观摩示例的 result\n2. 思考组件模板和逻辑实现思路\n3. 遇到问题先搜一下 api 和官方教程（好像看过一遍还是记不住什么。。。结合实践重要嗯）\n4. 还是不会就看例子的代码吧（不出意外的话都会走到这步哈哈）\n5. 整理一下代码和总结\n\n## markdown Editor\n一个极简的 markdown 编辑器，用了 marked 这个工具。\n\n- 新建一个 Marked 组件就 ok。看起来很简单，textarea 标签作为输入编辑器，另一个 div 标签通过 marked 这个 markdown工具 转码。\n- npm i marked --save 来安装好 marked，import 后通过定义过滤器实现。\n- textarea 设置了 debounce指令。debounce 设置一个最小的延时，在每次敲击之后延时同步输入框的值与数据。如果每次更新都要进行高耗操作（例如在输入提示中 Ajax 请求），它较为有用。\n\n```javascript\n<template>\n  <div id=\"marked\">\n    <textarea v-model=\"input\" debounce=500></textarea>\n    <div v-html=\"input|marked\"></div>\n  </div>\n</template>\n\n<script>\n  import marked from 'marked'\n  export default {\n    data () {\n      return {\n        // note: changing this line won't causes changes\n        // with hot-reload because the reloaded component\n        // preserves its current state and we are modifying\n        // its initial state.\n        input: '# Helzzz World!'\n      }\n    },\n    filters: {\n      marked: marked\n    }\n  }\n</script>\n```\n\n## github commits\n\n编写一个小组件，异步获取 github 的两条 branch的数据。\n\n- created:生命周期的钩子，在实例创建后同步调用。此时实例已经结束解析选项，意味着已经建立了数据绑定，计算属性，方法，watcher/事件回调。但是还没有开始 DOM 编译，$el 还不存在。\n- watch：一个对象，键是观察表达式，值是对应回调。值也可以是方法名，或者是对象，包含选项。在实例化时为每个键调用 $watch() 。\n- **遇到的问题**：eslint 总是提示 new XMLHttpRequest() 错误，not defined，并不知道为啥会这样，看到了很多代码也并没出错啊，暂时在 eslint 的配置文件把 no-undef 设为0忽略它了，如果有知道的童鞋可以指点一二。\n\n```javascript\n<template>\n  <div id=\"commits\">\n    <p>Latest vue.js Commits</p>\n    <template v-for=\"branch in branches\">\n      <label :for=\"branch\">\n        <input type=\"radio\"\n               name=\"branch\"\n               :id=\"branch\"\n               :value=\"branch\"\n               v-model=\"currentBranch\">\n        {{branch}}</label>\n    </template>\n    <p>vuejs/vue@{{currentBranch}}</p>\n    <ul>\n      <li v-for=\"record in commits\">\n        <a :href=\"record.html_url\" target=\"_blank\">dd</a>\n        - <span>{{record.commit.message}}</span>\n        by <span>{{record.commit.author.name}}</span>\n        at <span>{{record.commit.author.date}}</span>\n      </li>\n    </ul>\n  </div>\n</template>\n\n<script>\n  export default {\n    data () {\n      return {\n        branches: ['master', 'dev'],\n        currentBranch: 'master',\n        commits: null,\n        apiURL: 'https://api.github.com/repos/vuejs/vue/commits?per_page=3&sha='\n      }\n    },\n    created () { // 生命周期 created,获取数据\n      this.fetchData()\n    },\n    watch: {  // 观测变化,可以是值也可以是方法\n      currentBranch: 'fetchData'\n    },\n    methods: {\n      fetchData () {\n        let xhr = new XMLHttpRequest()\n        const self = this  // 下面的 onload事件中 this 不再指向实例,所以要变量存一下\n        xhr.open('GET', this.apiURL + this.currentBranch)\n        xhr.onload = function () {\n          self.commits = JSON.parse(xhr.responseText)\n        }\n        xhr.send()\n      }\n    }\n  }\n</script>\n```\n\n## Validation+Firebase\nfirebase 实时后端云简单搂了一眼，号称无后端数据存储加实时通信还是很带感的，不过自己写的时候总是报错，只好自己在本地 mock 一下了。以后写可以使用 wilddog，国内的\n\n- 计算属性：由于模板中只可以用表达式，相对复杂的逻辑并不适合放在模板中，所以计算属性就派上用场了，简单易用。计算属性默认只是 getter 函数，不过也可以自定义 getter 和 setter函数。\n- transition 过渡：这个过渡系统听勾股大大说很值得学习，所以暂时放下以后看源码先。\n- mock 数据对象以后比较蛋疼，会把 newUser这个对象直接 push 进 userRef 中，导致以后对 newUser 的操作都会被双向绑定显示到列表中。。。所以只好深拷贝一下数据 push 进去，这个留坑以后填。\n- !!:双叹号强制类型转换为布尔值。\n\n\n```html\n<template>\n  <ul>\n    <li class=\"user\" v-for=\"user in userRef\" transition>\n      <span>{{user.name}} - {{user.email}}</span>\n      <button @click=\"removeUser(user)\">X</button>\n    </li>\n  </ul>\n  <form @submit.prevent=\"addUser\">\n    <input type=\"text\" v-model=\"newUser.name\">\n    <input type=\"text\" v-model=\"newUser.email\">\n    <input type=\"submit\" value=\"Add User\">\n  </form>\n  <p v-show=\"!validation.name\">Name can not be empty</p>\n  <p v-show=\"!validation.email\">email is not validated</p>\n</template>\n```\n\n```javascript\n<script type=\"text/babel\">\n  const emailRE = /^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/\n\n  export default {\n    data () {\n      return {\n        newUser: {\n          name: '',\n          email: ''\n        },\n        userRef: [\n          {\n            name: 'hh',\n            email: '10218085@qq.com'\n          },\n          {\n            name: 'heheihe',\n            email: 'weirweoi@qq.com'\n          }\n        ]\n      }\n    },\n    computed: {\n      validation () {\n        return {\n          name: !!this.newUser.name.trim(),\n          email: emailRE.test(this.newUser.email)\n        }\n      },\n      isValid () {\n        const validation = this.validation\n        return Object.keys(validation).every(key => validation[key])\n      }\n    },\n    methods: {\n      addUser () {\n        if (this.isValid) {\n          let temp = JSON.parse(JSON.stringify(this.newUser))\n          this.userRef.push(temp)\n          this.newUser.name = ''\n          this.newUser.email = ''\n        }\n      },\n      removeUser (user) {\n        \n      }\n    }\n  }\n</script>\n```\n\n## 树状视图\n这个例子实现了树状视图，主要演示如何递归调用组件。\n\n- 递归组件：组件在自身的模板内可以递归调用自己，但是**要有 name 选项才可以**，在这上面花了好长时间又去查了教程才发现。。。官方示例代码用 Vue.component()注册了全局组件，会把 id 自动注册为name 属性，所以没有手动写 name 属性。我在 cli 里写的时候一直没注意，导致递归总是不显示嗯。\n- Vue.set:全局 API，设置对象的属性。如果对象是响应的，将触发视图更新。这个方法主要用于解决不能检测到属性添加的限制。\n- `open = !open`:这是用来 toggle 布尔值，又学了一招~\n- `@click和@dblclick`分别代表单击和双击事件绑定。后一个还真是没注意过。\n- 动态 props：可以绑定 props，这样父组件数据变化后，也会传递给子组件。\n\n```javascript\n<template>\n  <li>\n    <div @click=\"toggle\" @dblclick=\"changeType\">\n      {{model.name}}\n      <span v-if=\"isFolder\">[ {{open ? '-' : '+'}} ]</span>\n    </div>\n    <ul v-show=\"open\">\n      <Item :model=\"model\" v-for=\"model in model.children\">\n      </Item>\n      <li @click=\"addChild\">+</li>\n    </ul>\n  </li>\n</template>\n```\n\n```javascript\n<script type=\"text/babel\">\n  import Vue from 'vue'\n  export default {\n    name: 'item',\n    data () {\n      return {\n        open: false\n      }\n    },\n    props: {\n      model: Object\n    },\n    computed: {\n      isFolder () {\n        return this.model.children && this.model.children.length\n      }\n    },\n    methods: {\n      toggle () {\n        if (this.isFolder) {\n          this.open = !this.open\n        }\n      },\n      changeType () {\n        if (!this.isFolder) {\n          Vue.set(this.model, 'children', [])\n          this.addChild()\n          this.open = true\n        }\n      },\n      addChild () {\n        this.model.children.push({name: 'new staff'})\n      }\n\n    }\n  }\n```\n\n## 模态组件\n一个弹出层，用到了组件、props、slot内容分发、过渡。\n\n- slot:内容分发的一个东东，个人理解好像电脑主机的 pci 插槽，接口标准一致，可以插入不同的板子，比如 pci 网卡或者 pci声卡，根据 name 不同可以实现具名 slot，有需求的话别忘了设置 default的默认 slot嗯。\n- Props:写 react 的时候就接触过了，父组件可以通过 props 向下传递数据，这里又踩了坑，**子组件一定要显式声明 props 属性！！！！**折腾了好久才去查 api 和教程，真是浪费时间。。\n\n```javascript\n<template>\t// 父组件\n  <div id=\"app\">\n    <button @click=\"showModal = true\">show modal</button>\n    <modal :show.sync=\"showModal\">\n      <h3 slot=\"header\">heaaaaaader</h3>  具名 slot 传入\n    </modal>\n  </div>\n</template>\n\n<template> // 子组件\n  <div v-show=\"show\" class=\"modal-mask\" transition=\"modal\">\n    <div class=\"modal-wrapper\">\n      <div class=\"modal-container\" transition=\"modal\">\n\n        <div class=\"modal-header\">\n          <slot name=\"header\">default header</slot>\n        </div>\n\n        <div class=\"modal-body\">\n          <slot name=\"body\">default body {{show}}</slot>\n        </div>\n\n        <div class=\"modal-footer\">\n          <slot name=\"footer\">default footer</slot>\n          <button @click=\"show = false\" class=\"modal-default-button\">OK</button>\n        </div>\n\n      </div>\n    </div>\n  </div>\n</template>\n```\n\n```javascript\n<script type=\"text/babel\">\n  export default {\n    props: {\t\t//子组件一定别忘了声明 props\n      show: Boolean\n    }\n  }\n</script>\n```\n", 'JavaScript');